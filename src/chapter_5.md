```admonish warning 
**本章施工中**
```

<!-- toc -->

# 数据即代码，代码即数据
```admonish tip title="本章的学习目标"
- 理解计算中的最重要概念之一：代码与数据的二元性。
- 逐步熟悉程序的不同表示形式之间的转换。
- 学习构建一个“通用电路求值器”，能够根据给定表示执行其他电路。
- 认识与上一章结论相辅相成的重要成果：某些函数需要指数级数量的门电路才能实现。
- 探讨在物理意义上的Church-Turing论题--该论题指出布尔电路可以建模物理世界中所有可行的计算，并分析其背后的物理学原理与哲学意涵。
```

```admonish quote title=""
“密码脚本”这一术语显然过于狭隘。染色体结构同时是实现它们所预示的发展的工具——它们既是法律条文又是执行权力，或者用另一个比喻来说，它们同时是建筑师的设计图和施工者的技艺。

*——埃尔温·薛定谔（Erwin Schrödinger），1944年*
```

```admonish quote title=""
"数学家几乎不会将64种四个单元的三联体组合与二十种其他单元之间的对应关系称为‘普适’，而这种对应很可能是地球生命最根本的普遍特征。"

*——米沙·格罗莫夫（Misha Gromov），2013年*
```

程序就是由一系列符号组成的序列，每个符号都可以通过（例如）ASCII标准编码为由$0$和$1$组成的字符串。因此，我们可以将每个NAND-CIRC程序（进而每个布尔电路）表示为二进制字符串。这个论断看似浅显，实则意义深远--它意味着我们既可以将电路或NAND-CIRC程序视为执行计算的指令，也可以将其视为可能被其他计算用作输入的数据。

```admonish check title="重要启示6"
程序是文本的一种形式，因此可以作为其他程序的输入。
```

这种代码与数据的对应关系是计算科学最根本的特性之一。它构成了通用计算机概念的基础（使计算机不需要预先布线即可执行不同任务），也为实现通用人工智能的愿景提供了理论支撑。这一理念从脚本语言到机器学习等计算领域都有广泛应用，但客观而言，人类尚未完全掌握其精髓。许多安全漏洞（如[图5.1](#i51)所示的“缓冲溢出”案例）正是由于攻击者成功在系统仅预期接收“被动”数据的位置注入了可执行的代码。代码与数据的关联性甚至超越了电子计算机的范畴：例如DNA即可被视为程序也可被视为数据（正如薛定谔在DNA发现前出版的著作所言--这部著作后来启发了沃森与克里克--DNA同时承载着“建筑师的设计图”与“施工者的工艺”）。

```admonish quote title="图5.1"
<span id="i51"> ![#i51 .margin](./images/chapter5/exploits_of_a_mom.png)</span>
*正如这部xkcd漫画所阐释的，包括缓冲溢出、SQL注入在内的诸多漏洞利用技术，正是模糊了"动态程序"与"静态字符串"之间的界限*
```

```admonish tip title="本章的一个非数学化概览"
非数学化概述。本章将初步探讨代码与数据对应关系的多种应用。我们将首先通过将程序/电路表示为字符串的方式，统计特定规模内的程序/电路数量，并借此获得与[第4章](./chapter_4.md)结论相对应的成果——第四章我们证明了所有函数都可以通过电路计算，但该电路可能具有指数级规模（具体界限见[定理4.16]()）。本章将证明某些函数确实无法突破这个限制：计算这些函数的最小电路必然具有指数级规模。

我们还将利用程序/电路字符串化表示的概念，证明"通用电路"的存在性——即能够评估其他电路的电路。在编程语言领域，这被称为"元循环求值器"：用某编程语言编写的能评估同语言其他程序的程序。这些结论存在重要限制：通用电路的规模必须大于其评估的电路。我们将在[第7章](./chapter_7.md)引入循环和图灵机时展示如何突破这一限制。
```

本章成果概览参见[图5.2](#i52)。

```admonish quote title="图5.2"
<span id="i52"> ![#i52 .margin](./images/chapter5/codedataoverview.png)</span>
*本章结论概要。通过将程序/电路表示为字符串，我们推导出两个主要结论：首先证明通用程序/电路的存在性，且经过深化论证可知其规模最多为被执行的程序/电路规模的多项式倍；继而利用字符串表示统计特定规模程序/电路的数量，据此证实某些函数需要指数级别的代码行数/逻辑门数才能实现计算*
```

## 5.1 将程序表示为字符串 {#s51}
```admonish quote title="图5.3"
<span id="i53"> ![#i53 .margin](./images/chapter5/tapemarkI.png)</span>
*在哈佛Mark I计算机中，程序是由一系列数字三元组来表示的，这些数字三元组又由打孔纸板来表示*
```

我们可以用无数种方式将程序或电路表示为字符串。例如，由于布尔电路是带标签的有向无环图，我们可以使用**邻接矩阵**或**邻接表**来表示它们。然而，由于程序代码本质上只是字母和符号的序列，可以说程序在概念上最简单的表示就是这样的序列。例如，以下NAND-CIRC程序$P$：

```python
temp_0 = NAND(X[0],X[1])
temp_1 = NAND(X[0],temp_0)
temp_2 = NAND(X[1],temp_0)
Y[0] = NAND(temp_1,temp_2)
```

本质上是一个包含107个符号的字符串，这些符号包括大小写字母、数字、下划线`_`、等号`=`、标点符号（如“`(`”、“`)`”、“`,`”）、空格以及“换行”标记（通常表示为“`\n`”或“↵”）。每个这样的符号都可以通过[ASCII编码](https://en.wikipedia.org/wiki/ASCII)用7位二进制字符串表示，因此程序$P$可以被编码为一个长度为$7\cdot 107=749$位的字符串。

上述讨论中没有任何内容是特定于程序$P$的，因此我们可以用相同的推理证明每个NAND-CIRC程序都可以表示为${0,1}^*$中的字符串。实际上，我们可以做得更好。由于NAND-CIRC程序的工作变量名称不会影响其功能，我们总是可以将程序转换为$P'$的形式，其中除输入和输出之外的所有变量都具有temp_0、temp_1、temp_2等形式。此外，如果程序有$s$行，我们永远不需要使用大于$3s$的索引（因为每行最多涉及三个变量），同样地，输入和输出变量的索引也都不会超过$3s$。由于0到$3s$之间的数字最多可以用$\lceil \log_{10}(3s+1) \rceil = O(\log s)$位数字表示，程序中的每一行（形式为foo = NAND(bar,blah)）可以用$O(1) + O(\log s) = O(\log s)$个符号表示，每个符号又可以用7位表示。因此，一个$s$行程序可以表示为$O(s \log s)$位组成的字符串，由此得到以下定理：

```admonish quote title=""
{{thmc}}{thmc:t51}（将程序表示为字符串）

在一个常数$c$，使得对于$f \in SIZE(s)$，存在一个计算$f$的程序$P$，其字符串表示的长度最多为$c s \log s$。
```

```admonish pause title="暂停一下"
我们省略了{{tref:thmc:t51}}的正式证明，但请确保你理解为什么它可以从上述推理中得出。
```

## 5.2 程序数量统计与NAND-CIRC程序规模下界

将程序表示为字符串的必然结果是：特点长度的程序数量受限于可表示它们的字符串数量。这一结论对我们[4.6节]()定义的集合$SIZE_{n,m}(s)$具有重要意义。

```admonish quote title=""
{{thmc}}{thmc:t52}（程序计数定理）：

对于任意$s,n,m\in\N$，$SIZE_{n,m}(s)\le 2^{O(s\log s)}$。

这意味着最多存在$2^{O(s\log s)}$个函数可由不超过$s$行的NAND-CIRC程序计算。{{footnote: 其中$O(\cdot)$表示法中的隐常数小于10。也就是说，对于所有足够大的$s$，$|SIZ_{n,m}(s)<2^{10s\log s}|$，详见[备注5.2]()。如[1.7节](./chapter_1.md#17-本书所用到的符号及规范)所述，我们采用10这个界限值仅仅是因为它是个整数。}}
```

```admonish proof collapsible=true
对于任意$n,m\in\N$，我们将构造一个从$SIZE_{n,m}(s)$到长度为$cs\log s$的字符串集合的单射映射$E$（其中$c$为常数）。这将完成证明，因为该证明表明$|SIZE_{n,m}(s)|$小于长度至多为$\ell=cs\log s$的所有字符串集合的规模。根据等比数列求和公式，后一个集合的规模为$1+2+4+\cdots+2^\ell=2^{\ell+1}-1$。

映射$E$将简单地把函数$f$映射到计算$f$的最小程序表示。由于$f\in SIZE_{n,m}(s)$，根据{{tref:thmc:t51}}，存在一个最多$s$行的程序$P$，其字符串表示长度不超过$cs\log s$。此外，映射$f\mapsto E(f)$是单射，因为对于任意不同的函数$f,f':\{0,1\}^n\to\{0,1\}^m$，必然存在某个输入为$x\in\{0,1\}^n$使得$f(x)\ne f'(x)$。这意味着分别计算$f$和$f'$的程序不可能完全相同。
```

{{tref:thmc:t52}}有一个重要推论：可用小型电路/程序计算的函数数量远少于函数总数，因此必然存在需要非常大规模（实际上是指数级规模）电路才能计算的函数。理解这一点需要注意：映射$\{0,1\}^2$到$\{0,1\}$可由其在输入$00,01,10,11$上的四个值唯一确定;映射$\{0,1\}^3$到$\{0,1\}$的函数可尤其在输入$000,001,010,011,100,101,110,111$上的八个值唯一确定。更一般地，每个函数$F:\{0,1\}^n\to\{0,1\}$都可等同于其在$\{0,1\}^n$上$2^n$个取值组成的列表。因此，映射$\{0,1\}^n$到$\{0,1\}$的函数数量等于可能存在的$2^n$长度取值列表的数量，即$2^{2^n}$。注意这是关于$n$的双重指数函数，因此即使对于较小的$n$值（比如$n=10$），从$\{0,1\}^n$到$\{0,1\}$的函数数量也是真正的天文数字。{{footnote: “天文数字”在此是一种保守表述：可观测宇宙中的恒星数量甚至粒子数量都远少于$2^{2^{10} }$。}}如前所述，这引出了如下推论：

```admonish quote title=""
{{thmc}}{thmc:t53}（计数论证下界）

存在常数$\delta>0$，使得对于所有足够大的$n$，必然存在函数$f:\{0,1\}^n\to\{0,1\}$满足$f\notin SIZE_n\left(\tfrac{\delta 2^n}{n}\right)$。也就是说，计算$f$的最短NAND-CIRC程序需要超过$\delta\cdot 2^n/n$行。{{footnote: 常数$\delta$至少为0.1，实际上，可以通过[习题5.7]()将其进一步缩小为任意接近$1/2$的值。}}
```

```admonish proof collapsible=true
证明相当简单。令$c$为满足$|SIZE_n(s)|\le 2^{cs\log s}$的常数，且设$\delta=1/c$，则当$s=\delta 2^n/n$时，有：
$$
|SIZE_n(\tfrac{\delta 2^n}{n})| \leq 2^{c \tfrac{\delta 2^n}{n} \log s} < 2^{c \delta 2^n} = 2^{2^n}
$$
这里利用了$s<2^n$时$\log s<n$以及$\delta=1/c$的事实。由于$|SIZE_n(s)|$小于从$n$比特映射到1比特的函数总数，必然存在至少一个函数不属于$SIZE_n(s)$，这正是我们需要证明的结论。
```

我们此前已经知道：每个从$\{0,1\}^n$映射到$\{0,1\}$的函数都可由$O(2^n/n)$行程序计算。{{tref:thmc:t53}}表明了该界限是紧的，因为某些函数确实需要如此天文数字的行数才能计算。

```admonish check title="重要启示7"
某些函数$f:\{0,1\}^n\to\{0,1\}$无法通过门电路数量少于$n$的指数级的布尔电路来计算。
```

事实上，正如习题中所探讨的，**大多数**函数都属于这种情况。因此，能用少量代码行数计算的功能（如加法、乘法、图上的最短路径算法，甚至$EVAL$函数）只是例外而非普遍规律。

```admonish note title="备注5.4（更高效的表示方法，高级可选内容）" id="r54"
ASCII表示并非NAND-CIRC程序的最短表示形式。NAND-CIRC程序等价于带NAND门的电路，这意味着具有$s$行、$n$个输入和$m$个输出的NAND-CIRC程序可用包含$s+n$个顶点的标记有向图表示，其中$n$个顶点的入度为零，其余$s$个顶点的入度至多为二。使用此类图的邻接矩阵表示，我们可以将{{tref:thmc:t52}}中的隐常数降低到任意接近5的值，详见[习题5.6]()。
```

### 5.2.1 规模层次定理（可选）

由[定理4.15]()有$SIZE_n(10\cdot 2^n/n)$包含了**所有**由$\{0,1\}^n$到$\{0,1\}$的函数，而由{{tref:thmc:t53}}，存在一些**没有包含**在$SIZE_n(0.1\cdot 2^n/n)$中的函数$f:\{0,1\}^n\to\{0,1\}$。换而言之，对于充分大的$n$，有

$$
SIZE_n\left(0.1 \tfrac{2^n}{n} \right) \subsetneq SIZE_n\left(10 \tfrac{2^n}{n} \right)
$$

可以发现我们可以使用{{tref:thmc:t53}}来展示一个更加一般的结论：当我们增加我们门电路的“预算”的时候，我们就能计算新的函数。

```admonish quote title=""
{{thmc}}{thmc:t55}（规模层次定理）

对于所有充分大的$n$和$10n<s<0.1\cdot 2^n/n$，有
$$
SIZE_n(s)\subsetneq SIZE_n(s+10n)
$$
```

```admonish tip collapsible=true title="证明思路"
为了证明这个定理，我们需要找到一个函数$f:\{0,1\}^n\to\{0,1\}$，使得该函数可以由$s+10n$个门的电路计算，但**不能**被$s$个门的电路计算。为此，我们将构筑一个函数序列$f_0,f_1,f_2,\dots,f_N$，其满足以下性质：(1) $f_0$最多可用$10n$个门的电路计算;(2) $f_N$无法用$0.1\cdot 2^n/n$个门的电路计算;(3) 对每个$i\in\{0,\dots,N\}$，若$f_i$可用规模为$s$的电路计算，则$f_{i+1}$最多可用规模为$s+10n$的电路计算。这些性质共同表明：若令$i$是满足$f_i\notin SIZE_n(s)$的最小下标，则由于$f_{i-1}\in SIZE_n(s)$，必然有$f_i\in SIZE_n(s+10n)$，这正是我们需要证明的结论。示意图见[图5.4](#i54)。
```

```admonish quote title="图5.4"
<span id="i54">![i54 .margin](./images/chapter5/hierarchyproof.png)</span>
*我们通过构造函数列表$f_0,\ldots,f_{2^n}$来证明{{tref:thmc:t55}}，其中$f_0$是全零函数，$f_{2^n}$是（由{{tref:thmc:t53}}得到的）不在$SIZE_n(0.1\cdot 2^n/n)$中的函数，且满足$f_{i-1}$与$f_i$最多在一个输入上存在差异。可以证明：对每个$i$，计算$f_i$所需的门数最多比计算$f_{i-1}$多$10n$个。因此若令$i$是满足$f_i \not\in SIZE_n(s)$的最小下标，则$f_i \in SIZE_n(s+10n)$*
```

```admonish proof collapsible=true
设$f^*:\{0,1\}^n\to\{0,1\}$是由{{tref:thmc:t53}}保证存在的函数，且满足$f^*\notin SIZE_n(0.1\cdot 2^n/n)$。我们定义函数序列$f_0,f_1,\dots,f_{2^n}:\{0,1\}^n\to\{0,1\}$如下：对任意$x\in\{0,1\}^n$，若$lex(x)\in\{0,1,\dots,2^n-1\}$是$x$在字典序中的编号，则
$$
f_i(x) = \begin{cases} f^*(x) & lex(x)< i  \\ 0 & \text{otherwise} \end{cases}
$$
函数$f_0$是常值零函数，而$f_{2^n}$等于$f^*$。此外，对每个$i\in[2^n]$，函数$f_i$与$f_{i+1}$最多在一个输入上存在差异（即满足$lex(x)=i$的输入$x\in\{0,1\}^n$）。

设$10n<s<0.1\cdot 2^n/n$，并令$i$是满足$f_i\notin SIZE_n(s)$的最小下标。由于$f_{2^n}=f^*\notin SIZE_n(0.1\cdot 2^n/n)$，这样的下标$i$必然存在，且因常值零函数属于$SIZE_n(10n)$，故$i>0$。

根据$i$的选取，$f_{i-1}$属于$SIZE_n(s)$。为完成证明，需要证明$f_i\in SIZE_n(s+10n)$。令$x^*$是满足$lex(x^*)=i$的字符串，$b\in\{0,1\}$为$f^*(x^*)$的值。则$f_i$也可定义为
$$
f_i(x) = \begin{cases} b & x=x^* \\ f_{i-1}(x) & x \neq x^*
         \end{cases}
$$
即
$$
f_i(x) = IF(EQUAL(x^*,x),b,f_{i-1}(x))
$$
其中$EQUAL:\{0,1\}^{2n}\to\{0,1\}$ 是将$x,x'\in\{0,1\}^n$ 映射到$1$（若两者相等）或$0$（否则）的函数。由$i$的选取可知，$f_{i-1}$最多可用$s$个门计算，且易证$EQUAL\in SIZE_n(9n)$，因此$f_i$最多可用$s+9n+O(1)\leq s+10n$个门计算，得证。
```

```admonish quote title=""
<span id="i55">![i55 .margin](./images/chapter5/sizecomplexity.png)</span>
*关于规模复杂度类已知结论的示意图（未按比例绘制）。该图描绘了形如$SIZE_{n,n}(s)$的类，但其他规模复杂度类（如$SIZE_{n,1}(s)$）的情况类似。由[定理4.12]()（结合[4.4.2节]()的改进）可知：所有$n$比特到$n$比特的函数都可由规模为$c\cdot 2^n$（$c\leq 10$）的电路计算；另一方面，计数下界（{{tref:thmc:t53}}，另见[习题5.4]()）表明某些函数需要$0.1 \cdot 2^n$个门；规模分层定理（{{tref:thmc:t55}}）则证明当$s=o(S)$时必然存在属于$SIZE_n(S)\setminus SIZE_n(s)$的函数，另见[习题5.5]()。*

*我们还考虑了一些具体示例：两个$n/2$比特数的加法可在$O(n)$线路中完成，而两个$n$比特数的乘法目前尚无此类程序，但已知可在$O(n^2)$甚至更优规模内完成。上图中的$FACTOR_n$对应乘法的逆问题——求给定整数的质因数分解。目前尚未发现任何具有多项式（甚至次指数）级别线路数量的电路能计算$FACTOR_n$。*
```

```admonish note title="备注5.6"
虽然规模分层定理保证了存在某些函数（例如）可用$n^2$个门计算但不能用$100n$个门计算，但我们尚未找到这类函数的显式案例。尽管我们怀疑整数乘法属于此类，但目前尚无证明。
```

## 5.3 元组表示
ASCII码能很好地呈现程序，但对某些应用场景而言，采用更具体的NAND-CIRC程序表示方法更为实用。本节将介绍一种便于后续使用的特定表示方案。

NAND-CIRC程序本质上是由若干行如下形式的语句构成的序列：

```python
blah = NAND(baz,boo)
```

变量命名本身并不具有特殊性。尽管可读性会降低，但我们完全可以仅使用`temp_0`、`temp_1`等工作变量来编写所有程序。因此，我们的NAND-CIRC程序表示法将忽略变量实际名称，转而采用为每个变量分配**编号**的方案。我们将程序中的每一行编码为数字三元组。若某行形式为`foo = NAND(bar,blah)`，则将其编码为三元组$(i,j,k)$，其中$i$对应变量`foo`的编号，$j$和$k$分别对应`bar`和`blah`的编号。

具体而言，我们将为每个变量分配集合$[t]={0,1,\ldots,t-1}$中的唯一编号。前$n$个数字${0,\ldots,n-1}$对应**输入**变量，最后$m$个数字${t-m,\ldots,t-1}$对应**输出**变量，中间数字${n,\ldots,t-m-1}$则对应剩余的"工作区"变量。形式化定义如下：

```admonish quote title=""
{{defc}}{defc:d57}（元组列表表示法）

设$P$是一个具有$n$个输入、$m$个输出、$s$行代码的NAND-CIRC程序，$t$是该程序使用的不同变量总数。则$P$的**元组列表表示**是一个三元组$(n,m,L)$，其中$L$是由$[t]$集合中数字构成的三元组$(i,j,k)$组成的列表。

变量编号分配规则如下：

- 对任意$i\in [n]$，变量X[$i$]被赋予编号$i$
- 对任意$j\in [m]$，变量Y[$j$]被赋予编号$t-m+j$
- 其余变量按照在程序$P$中出现的顺序，依次被赋予${n,n+1,\ldots,t-m-1}$中的编号
```

元组列表表示法是我们在表示NAND-CIRC程序时默认采用的方案。鉴于"元组列表表示法"这个名称略显冗长，我们通常直接称其为程序的"表示法"。当输入数量$n$和输出数量$m$可通过上下文明确时，我们有时会直接用列表$L$而非三元组$(n,m,L)$来表示程序。

```admonish example title="示例5.8（异或程序的表示）"
我们熟悉的计算异或函数的NAND-CIRC程序：

~~~python
u = NAND(X[0],X[1])
v = NAND(X[0],u)
w = NAND(X[1],u)
Y[0] = NAND(v,w)
~~~

可表示为元组$(2,1,L)$，其中$L=((2, 0, 1), (3, 0, 2), (4, 1, 2), (5, 3, 4))$。具体而言：变量`X[0]`和`X[1]`分别被赋予编号$0$和$1$，变量`u`，`v`，`w`分别被赋予编号$2,3,4$，变量`Y[0]`被赋予编号$5$。
```

将NAND-CIRC程序从代码表示转换为元组列表表示是一项直观的编程任务，仅需几行**Python**代码即可实现{{footnote: 若想了解具体实现代码，请参阅我们的[GitHub代码库](https://github.com/boazbk/tcscode)}}。虽然元组列表表示法会丢失变量命名等信息，但这并不影响程序功能，因此完全可接受。

### 5.3.1 从元组到字符串

如果程序$P$的规模为$s$，则其变量数量$t$最多为$3s$（因为每行代码最多涉及三个变量）。因此我们可以通过补前导零的方式，将每个在$[t]$范围内的变量索引编码为长度为$\ell = \ceil{\log (3s)}$的字符串。由于这是定长编码，自然满足无前缀性，因此我们可以将$s$个三元组组成的列表$L$（对应程序的$s$行编码）简单地表示为所有编码连接而成的长度为$3\ell s$的字符串。

我们定义$S(s)$为表示规模$s$程序对应列表$L$的字符串长度。由上述推导可得：

$$
S(s) = 3s\ceil{\log (3s)} {{numeq}}{eq51}
$$

我们可以通过将$n$和$m$的无前缀表示作为前缀附加到列表$L$之前，从而将$P=(n,m,L)$表示为字符串。由于$n,m \leq 3s$（程序必须至少涉及其所有输入和输出变量各一次），这些无前缀表示可以用长度为$O(\log s)$的字符串进行编码。特别地，每个最多包含$s$行代码的程序$P$都可以用长度为$O(s\log s)$的字符串表示。类似地，每个最多包含$s$个逻辑门的电路$C$也可用长度为$O(s \log s)$的字符串表示（例如通过将$C$转换为等效程序$P$实现）。

## 5.4 使用NAND-CIRC实现的NAND-CIRC程序解释器

既然程序可以表示为字符串，我们亦可将程序本身作为一个函数的输入。更具体地，对于每个自然数$s,n,m>0$我们定义函数$EVAL_{s,n,m}:\{0,1\}^{S(s)+n}\to\{0,1\}^m$如下：
$$
EVAL_{s,n,m}(px) = \begin{cases} P(x) & \text{$p\in \{0,1\}^{|S(s)|}$ 表示一个大小为$s$的，有$n$个输入和$m$个输出的程序$P$}  \\ 0^m & \text{其他情况} \end{cases} {{numeq}}{eq52}
$$
其中$S(s)$已在{{eqref:eq51}}中定义，同时，我们使用在[5.1节](#s51)中介绍的具体表示方案。

换而言之，$EVAL_{s,n,m}$接受两个字符串的拼接作为输入：字符串$p\in\{0,1\}^{|S(s)|}$和字符串$x\in\{0,1\}^n$。若$p$是表示三元组列表$L$的字符串，且$(n,m,L)$是某个规模为$s$的NAND-CIRC程序$P$的元组列表表示，则$EVAL_{s,n,m}(px)$等于程序$P$在输入$x$的求值结果$P(x)$。否则，$EVAL_{s,n,m}(px)$等于$0^m$（这种情况并不重要，$0^m$只是表示错误的“垃圾值”）。

**核心要点**：$EVAL_{s,n,m}$定义的具体细节并不重要，但以下要点需要记忆：
- $EVAL_{s,n,m}$是一个有限函数，接受固定长度的字符串作为输入，并输出固定长度的字符串。
- $EVAL_{s,n,m}$是单一函数，计算该函数可对**任意**固定长度的NAND-CIRC的程序在对应长度下的**任意**输入进行求值。
- $EVAL_{s,n,m}$是一个**函数**，而非**程序**（回忆[3.7.2节](./chapter_3.md#specvsimplrem)中的讨论）。即$EVAL_{s,n,m}$是描述输入与输出对应关系的**规范**。是否存在计算 $EVAL_{s,n,m}$ 的程序（即该函数的实现）是一个独立问题，需要另行证明（我们将在{{tref:thmc:t59}}中实现，并在{{tref:thmc:t510}}中给出更高效的程序）。

本书中我们将首次遇到的**自我循环**的示例是以下定理，可将其理解为“用NAND-CIRC实现的NAND-CIRC解释器”：

```admonish quote title=""
{{thmc}}{thmc:t59}（NAND-CIRC程序的有界通用性）

对于所有满足$s\geq m$ 的 $s,n,m \in \N$，存在一个计算函数$EVAL_{s,n,m}$的NAND-CIRC程序$U_{s,n,m}$。
```

也就是说，NAND-CIRC程序$U_{s,n,m}$能够接受**任何其他NAND-CIRC程序**（需满足特定长度和输入/输出要求）的描述以及**任意输入**$x$，并计算程序$P$在输入$x$下的结果。根据NAND-CIRC程序与布尔电路的等价性，我们也可以将$U_{s,n,m}$视为一个接受其他电路描述及其输入，并返回其求值结果的电路（参见[图5.6](#i56)）。我们将这个计算 、$EVAL_{s,n,m}$的NAND-CIRC程序$U_{s,n,m}$称为**有界通用程序**（或**通用电路**，参见[图5.6](#i56)）。“通用”意味着这是一个可以执行**任意**代码的**单一**程序，而“有界”表示$U_{s,n,m}$仅能评估有限规模的程序。当然这种限制是NAND-CIRC编程语言固有的，因为一个$s$行的程序（或等效的$s$个门的电路）最多只能接受$2s$个输入。后续在[第7章](./chapter_7.md)中，我们将引入**循环**的概念（以及**图灵机模型**），从而突破这一限制。

```admonish proof collapsible=true
{{tref:thmc:t59}}是一个重要结果，但其证明实际上并不困难。具体而言，由于$EVAL_{s,n,m}$是一个有限函数，{{tref:thmc:t59}}是[定理4.12]()的直接推论，后者表明每个有限函数都可以由某个NAND-CIRC程序计算。
```

```admonish pause title="暂停一下"
{{tref:thmc:t59}}简洁但重要。请确保您理解该定理的含义，以及它为何是[定理4.12]()的推论。
```

```admonish quote title="图5.6"
<span id="i56">![i56 .margin](./images/chapter5/universalcircuit.png)</span>
*通用电路$U$是一种电路，它接收任意（较小）电路$P$的二进制字符串描述作为输入，同时接收输入$x$，并输出字符串$P(x)$——即电路$P$在输入$x$上的求值结果。我们也可以将$U$视为一个直线程序：它接收另一个直线程序$P$的代码及输入$x$，最终输出$P(x)$的计算结果*
```

### 5.4.1 高效通用程序

{{tref:thmc:t59}}虽然确立了存在计算函数$EVAL_{s,n,m}$的NAND-CIRC程序，但并未明确限定该程序规模的边界。我们用于证明[定理4.9]()的{{tref:thmc:t59}}仅能保证存在一个规模可能达到输入长度**指数级**的NAND-CIRC程序。这意味着即使对于中等规模的$s,n,m$参数（例如 $n=100,s=300,m=1$），计算$EVAL_{s,n,m}$所需的NAND程序行数甚至可能超过可观测宇宙中的原子数量！幸运的是，我们能够实现比这好得多的方案。事实上，对于任意$s,n,m$，都存在一个输入长度为**多项式级**规模的NAND-CIRC程序可计算$EVAL_{s,n,m}$，如下述定理所示：

```admonish quote title=""
{{thmc}}{thmc:t510}（NAND-CIRC程序的高效有界通用性）

对于每个$s,n,m\in\N$，存在一个最多包含$O(s^2\log s)$行代码的NAND-CIRC程序，可计算上述定义的函数$EVAL_{s,n,m}:\{0,1\}^{S+n}\to\{0,1\}^m$（其中$S$表示用二进制表示$s$行的程序时所需要的位数）。
```

```admonish pause title="暂停一下"
若你尚未接触相关内容，建议此时回顾[1.4.8节](./chapter_1.md#148-渐近分析与大o表示法)中关于大$O$表示法的说明。需要特别指出的是，{{tref:thmc:t510}}的等价表述为：**存在**常数$c>0$，使得**对于任意**$s,n,m\in\N$，都存在一个最多包含$cs^2 \log s$行代码的NAND-CIRC程序$P$可计算函数$EVAL_{s,n,m}$。
```

与{{tref:thmc:t59}}不同，{{tref:thmc:t510}}并非“任意有限函数均可用电路计算”这一事实的平凡推论。证明{{tref:thmc:t510}}需要构造一个具体的NAND-CIRC程序来计算$EVAL_{s,n,m}$函数，我们将通过以下阶段实现：

1. 首先用“伪代码”描述计算$EVAL_{s,n,m}$的算法流程；
2. 随后展示如何用**Python**编写实现该函数的程序（无需深入掌握Python知识，任何具备编程语言基础的读者都能理解）；
3. 最终演示如何将此Python程序转化为NAND-CIRC程序。

这种方法不仅证明了{{tref:thmc:t510}}，更揭示了重要规律：我们总是可以将Python等高级语言的（无循环）代码转化为NAND-CIRC程序（进而转化为布尔电路）。

### 5.4.2 “伪代码”形式的NAND-CIRC解释器

### 5.4.3 Python实现的NAND解释器

### 5.4.4 用NAND-CIRC构建NAND-CRIC解释器

## 5.5 用NAND-CIRC实现Python解释器（讨论）

## 5.6 物理扩展Church-Turing论题（讨论）

### 5.6.1 反驳PECTT的尝试

## 5.7 第一部分的回顾：有限计算

## 5.8 习题

```admonish question title=""
{{proc}}{proc:q51}

以下哪一项陈述是错误的：

a. 存在一个$O(s^3)$行的NAND-CIRC程序，当输入为采用元组列表表示法的$s$行的程序$P$且所有输入均为$1$时，能够计算$P$的输出。

b. 存在一个$O(s^3)$行的NAND-CIRC程序，当输入为使用ASCII编码（以$7s$位字符串表示）的$s$字符程序$P$且所有输入均为$1$时，能够计算$P$的输出。

c. 存在一个$O(\sqrt{s})$行的NAND-CIRC程序，当输入为采用元组列表表示法的$s$行程序$P$且所有输入均为$1$时，能够计算$P$的输出。
```

```admonish question title=""
{{proc}}{proc:q52}（等值函数）

对于每个$k\in\N$，证明存在一个$O(k)$行的NAND-CIRC程序，用于计算函数$EQUAL_k:\{0,1\}^{2k}\to\{0,1\}$，其中当且仅当$x=x'$时，$EQUALS(x,x')=1$。
```

```admonish question title=""
{{proc}}{proc:q53}（等于常数的函数）

对于每个$k\in\N$和$x'\in\{0,1\}^k$，证明存在一个$O(k)$行NAND-CIRC程序，用于计算函数$EQUALS_{x'}:\{0,1\}^k\to\{0,1\}$，该函数在输入$x\in\{0,1\}^k$时，当且仅当$x=x'$时输出$1$。
```

```admonish question title=""
{{proc}}{proc:q54}（多输出函数的计数下界）

证明存在一个数$\delta>0$，使得对于每个足够大的$n$和每个$m$，存在一个函数$f:\{0,1\}^n\to\{0,1\}^m$，需要至少$\delta m\cdot 2^n/n$个NAND门来计算。提示见脚注。{{footnote: 存在多少个从$\{0,1\}^n$到$\{0,1\}^m$的函数？注意，我们对电路的定义要求每个输出对应一个唯一的门，尽管这一限制最多会对门数产生$O(m)$的附加差异。}}
```

```admonish question title=""
{{proc}}{proc:q55}（多输出函数的规模层次定理）

证明存在一个数$C$，使得对于每个$n,m$和$n+m<s<m\cdot 2^n/(Cn)$，存在一个函数$f\in SIZE_{n,m}(C\cdot s)\setminus SIZE_{n,m}(s)$。提示见脚注。{{footnote: 遵循{{tref:thmc:t55}}证明，将计数论证的使用替换为{{tref:proc:q54}}。}}
```

```admonish question title=""
{{proc}}{proc:q56}（电路的高效表示和更紧的计数上界）
使用[备注5.4](#r54)的思想证明，对于每个$\epsilon>0$和足够大的$s,n,m$，
$$
|SIZE_{n,m}(s)| < 2^{(2+\epsilon)s \log s + n\log n + m\log s}
$$
并得出结论：在{{tref:thmc:t52}}中的隐常数可以任意接近$5$。提示见脚注。{{footnote: 使用邻接表表示法，具有$n$个入度为零的顶点和$s$个入度为二的顶点的图可以用大约$2s\log(s+n) \leq 2s (\log s + O(1))$位表示。$n$个输入顶点和$m$个输出顶点的标记可以通过$[n]$中的$n$个标记列表和$[m]$中的$m$个标记列表来指定。}}
```

```admonish question title=""
{{proc}}{proc:q57}（更紧的计数下界）

证明对于每个$\delta< 1/2$，如果$n$足够大，则存在一个函数$f:\{0,1\}^n\to\{0,1\}$，使得$f \not\in SIZE_{n,1}\left( \tfrac{\delta 2^n}{n} \right)$。提示见脚注。{{footnote: 提示：使用{{tref:proc:q56}}的结果，并注意在此范围内$m=1$且$n\ll s$。}}
```

```admonish question title=""
{{proc}}{proc:q58}（随机函数的难计算性）

假设$n>1000$，并且我们随机选择一个函数$F:\{0,1\}^n\to\{0,1\}$，对于每个$x\in\{0,1\}^n$，$F(x)$的值通过投掷独立的无偏硬币来确定。证明存在一个$2^n/(1000n)$行程序来计算$F$的概率至多为$2^{-100}$。{{footnote: 提示：等价的说法是，你需要证明使用最多$2^n/(1000n)$行可以计算的函数集合的元素个数少于$2^{-100}2^{2^n}$。你能看出为什么吗？}}
```

```admonish question title=""
{{proc}}{proc:q59}

以下是一个表示NAND程序的元组：$(3, 1, ((3, 2, 2), (4, 1, 1), (5, 3, 4), (6, 2, 1), (7, 6, 6), (8, 0, 0), (9, 7, 8), (10, 5, 0), (11, 9, 10)))$。

1. 按照顺序写出八个值$P(000)$、$P(001)$、$P(010)$、$P(011)$、$P(100)$、$P(101)$、$P(110)$、$P(111)$的表格。
2. 用文字描述该程序的功能。
```

```admonish question title=""
{{proc}}{proc:q510}（使用XOR的EVAL）

对于每个足够大的$n$，设$E_n:\{0,1\}^{n^2}\to\{0,1\}$是一个函数，它接受一个长度为$n^2$的字符串，该字符串编码一对$(P,x)$，其中$x\in\{0,1\}^n$，$P$是一个具有$n$个输入、单个输出且最多$n^{1.1}$行的NAND程序，并返回$P$在$x$上的输出。{{footnote: 注意，如果$n$足够大，那么很容易用$n^2$位表示这样的一对，因为我们可以用$O(n^{1.1}\log n)$位表示程序，并且我们总是可以将表示填充到恰好$n^2$长度。}}即，$E_n(P,x)=P(x)$。

证明对于每个足够大的$n$，**不存在一个**XOR电路$C$来计算函数$E_n$，其中XOR电路包含$XOR$门以及常量$0$和$1$（参见[第18章](./chapter_18.md)）。即，证明存在某个常数$n_0$，使得对于每个$n>n_0$和具有$n^2$个输入与单个输出的XOR电路$C$，存在一对$(P,x)$，使得$C(P,x) \neq E_n(P,x)$。
```

```admonish question title=""
{{proc}}{proc:q511}（学习电路（挑战性，可选，需要更多背景知识））

（本练习假设你可能此时不具备概率论和/或机器学习的背景知识。可以在后续阶段，特别是在学习[第18章](./chapter_18.md)之后再来回顾。）
在本练习中，我们将使用对大小为$s$的电路数量的界限来表明（如果我们忽略计算成本）每个这样的电路都可以从不太多的训练样本中**学习**。
具体来说，如果我们找到一个大小为$s$的电路，该电路在来自某个分布$D$的$O(s \log s)$个训练样本上正确分类，那么可以保证它在整个分布$D$上表现良好。
由于布尔电路建模了许多物理过程（如果（有争议的）PECTT成立，可能包括所有过程），这表明所有这样的过程也可以被学习（再次忽略在训练数据上找到表现良好的分类器的计算成本）。

设$D$是$\{0,1\}^n$上的任意概率分布，$C$是一个具有$n$个输入、一个输出且规模为$s \geq n$的NAND电路。
证明存在某个常数$c$，使得以下情况以至少$0.999$的概率成立：如果$m = c s \log s$且$x_0,\ldots,x_{m-1}$是从$D$中独立选取的，那么对于每个电路$C'$，如果在每个$i \in [m]$上$C'(x_i)=C(x_i)$，则$\Pr_{x \sim D}[C'(x) \leq C(x)] \leq 0.99$。

换句话说，如果$C'$是一个所谓的“经验风险最小化器”，在所有训练样本$x_0,\ldots,x_{n-1}$上与$C$一致，那么它也有高概率与从分布$D$中抽取的样本上的$C$一致（即，使用机器学习术语来说，它“泛化”了）。提示见脚注。{{footnote: 提示：使用我们对大小为$s$的程序/电路数量的界限{{tref:thmc:t52}}，以及Chernoff界（[定理18.12]()）和联合界。}}
```

## 5.9 参考书目

$EVAL$函数通常被称为**通用电路**。我们在本章中所描述的实现并非目前已知最高效的。Valiant（[Valiant](https://scholar.google.com/scholar?hl=en&q=Valiant+Universal+circuits+(preliminary+report))）最早提出了规模为$O(n\log n)$的通用电路（其中$n$表示输入规模）。近年来，由于在密码学中的应用（参见[Lipmaa, Mohassel, Sadeghian, 2016](https://scholar.google.com/scholar?hl=en&q=Lipmaa,+Mohassel,+Sadeghian+Valiant%27s+Universal+Circuit:+Improvements,+Implementation,+and+Applications.)，[Günther, Kiss, Schneider, 2017](https://scholar.google.com/scholar?hl=en&q=G%C3%BCnther,+Kiss,+Schneider+More+efficient+universal+circuit+constructions)），通用电路获得了新的研究动力。

尽管我们已经知道“大多数”将$n$比特映射到1比特的函数需要规模为指数级$\Omega(2^n/n)$的电路，但事实上我们尚未找到任何一个**显式**函数能够被**证明**需要至少$n^{100}$甚至$100n$规模的电路。目前已知的最强下界表明：存在非常简洁且显式的$n$变量函数，其计算至少需要$(5-o(1))n$线路（参见[Iwama等人的论文](http://www.wisdom.weizmann.ac.il/~ranraz/publications/P5nlb.pdf)以及[Kulikov等人更近期的研究](http://logic.pdmi.ras.ru/~kulikov/papers/2012_5n_lower_bound_cie.pdf)）。针对受限电路模型证明下界是一个极具吸引力的研究领域，Jukna的著作（[Jukna, 2012](https://scholar.google.com/scholar?hl=en&q=Jukna+Boolean+function+complexity:+advances+and+frontiers)）（另见Wegener（[Wegener, 1987](https://scholar.google.com/scholar?hl=en&q=Wegener+The+complexity+of+Boolean+functions)））为此提供了优秀的入门指南和综述。
本人从Sasha Golovnev处获悉规模分层定理（{{tref:thmc:t55}}）的证明。

Scott Aaronson关于[信息具有物理性的博客文章](http://www.scottaaronson.com/blog/?p=3327)，对PECTT相关议题进行了精彩探讨。其关于NP完全问题与物理现实的综述（[Aaronson, 2005](https://scholar.google.com/scholar?hl=en&q=Aaronson+NP-complete+problems+and+physical+reality)）也讨论了这些议题，不过建议在学完[第15章](./chapter_15.md)中关于$\mathbf{NP}$与$\mathbf{NP}$完全性的内容后再阅读会更易理解。