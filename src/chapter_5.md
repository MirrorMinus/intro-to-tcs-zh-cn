```admonish warning 
**本章施工中**
```

# 数据即代码，代码即数据
```admonish tip title="本章的学习目标"
- 理解计算中的最重要概念之一：代码与数据的二元性。
- 逐步熟悉程序的不同表示形式之间的转换。
- 学习构建一个“通用电路求值器”，能够根据给定表示执行其他电路。
- 认识与上一章结论相辅相成的重要成果：某些函数需要指数级数量的门电路才能实现。
- 探讨在物理意义上的Church-Turing论题--该论题指出布尔电路可以建模物理世界中所有可行的计算，并分析其背后的物理学原理与哲学意涵。
```

```admonish quote title=""
“密码脚本”这一术语显然过于狭隘。染色体结构同时是实现它们所预示的发展的工具——它们既是法律条文又是执行权力，或者用另一个比喻来说，它们同时是建筑师的设计图和施工者的技艺。

*——埃尔温·薛定谔（Erwin Schrödinger），1944年*
```

```admonish quote title=""
"数学家几乎不会将64种四个单元的三联体组合与二十种其他单元之间的对应关系称为‘普适’，而这种对应很可能是地球生命最根本的普遍特征。"

*——米沙·格罗莫夫（Misha Gromov），2013年*
```

程序就是由一系列符号组成的序列，每个符号都可以通过（例如）ASCII标准编码为由$0$和$1$组成的字符串。因此，我们可以将每个NAND-CIRC程序（进而每个布尔电路）表示为二进制字符串。这个论断看似浅显，实则意义深远--它意味着我们既可以将电路或NAND-CIRC程序视为执行计算的指令，也可以将其视为可能被其他计算用作输入的数据。

```admonish check title="核心思想6"
程序是文本的一种形式，因此可以作为其他程序的输入。
```

这种代码与数据的对应关系是计算科学最根本的特性之一。它构成了通用计算机概念的基础（使计算机不需要预先布线即可执行不同任务），也为实现通用人工智能的愿景提供了理论支撑。这一理念从脚本语言到机器学习等计算领域都有广泛应用，但客观而言，人类尚未完全掌握其精髓。许多安全漏洞（如[图5.1](#i51)所示的“缓冲溢出”案例）正是由于攻击者成功在系统仅预期接收“被动”数据的位置注入了可执行的代码。代码与数据的关联性甚至超越了电子计算机的范畴：例如DNA即可被视为程序也可被视为数据（正如薛定谔在DNA发现前出版的著作所言--这部著作后来启发了沃森与克里克--DNA同时承载着“建筑师的设计图”与“施工者的工艺”）。

```admonish quote title="图5.1"
<span id="i51"> ![#i51 .margin](./images/chapter5/exploits_of_a_mom.png)</span>
*正如这部xkcd漫画所阐释的，包括缓冲溢出、SQL注入在内的诸多漏洞利用技术，正是模糊了"动态程序"与"静态字符串"之间的界限*
```

```admonish tip title="本章的一个非数学化概览"
非数学化概述。本章将初步探讨代码与数据对应关系的多种应用。我们将首先通过将程序/电路表示为字符串的方式，统计特定规模内的程序/电路数量，并借此获得与[第4章](./chapter_4.md)结论相对应的成果——第四章我们证明了所有函数都可以通过电路计算，但该电路可能具有指数级规模（具体界限见[定理4.16]()）。本章将证明某些函数确实无法突破这个限制：计算这些函数的最小电路必然具有指数级规模。

我们还将利用程序/电路字符串化表示的概念，证明"通用电路"的存在性——即能够评估其他电路的电路。在编程语言领域，这被称为"元循环求值器"：用某编程语言编写的能评估同语言其他程序的程序。这些结论存在重要限制：通用电路的规模必须大于其评估的电路。我们将在[第7章](./chapter_7.md)引入循环和图灵机时展示如何突破这一限制。
```

本章成果概览参见[图5.2](#i52)。

```admonish quote title="图5.2"
<span id="i52"> ![#i52 .margin](./images/chapter5/codedataoverview.png)</span>
*本章结论概要。通过将程序/电路表示为字符串，我们推导出两个主要结论：首先证明通用程序/电路的存在性，且经过深化论证可知其规模最多为被执行的程序/电路规模的多项式倍；继而利用字符串表示统计特定规模程序/电路的数量，据此证实某些函数需要指数级别的代码行数/逻辑门数才能实现计算*
```

## 5.1 将程序表示为字符串
```admonish quote title="图5.3"
<span id="i53"> ![#i53 .margin](./images/chapter5/tapemarkI.png)</span>
*在哈佛Mark I计算机中，程序是由一系列数字三元组来表示的，这些数字三元组又由打孔纸板来表示*
```

我们可以用无数种方式将程序或电路表示为字符串。例如，由于布尔电路是带标签的有向无环图，我们可以使用**邻接矩阵**或**邻接表**来表示它们。然而，由于程序代码本质上只是字母和符号的序列，可以说程序在概念上最简单的表示就是这样的序列。例如，以下NAND-CIRC程序$P$：

```python
temp_0 = NAND(X[0],X[1])
temp_1 = NAND(X[0],temp_0)
temp_2 = NAND(X[1],temp_0)
Y[0] = NAND(temp_1,temp_2)
```

本质上是一个包含107个符号的字符串，这些符号包括大小写字母、数字、下划线`_`、等号`=`、标点符号（如“`(`”、“`)`”、“`,`”）、空格以及“换行”标记（通常表示为“`\n`”或“↵”）。每个这样的符号都可以通过[ASCII编码](https://en.wikipedia.org/wiki/ASCII)用7位二进制字符串表示，因此程序$P$可以被编码为一个长度为$7\cdot 107=749$位的字符串。

上述讨论中没有任何内容是特定于程序$P$的，因此我们可以用相同的推理证明每个NAND-CIRC程序都可以表示为${0,1}^*$中的字符串。实际上，我们可以做得更好。由于NAND-CIRC程序的工作变量名称不会影响其功能，我们总是可以将程序转换为$P'$的形式，其中除输入和输出之外的所有变量都具有temp_0、temp_1、temp_2等形式。此外，如果程序有$s$行，我们永远不需要使用大于$3s$的索引（因为每行最多涉及三个变量），同样地，输入和输出变量的索引也都不会超过$3s$。由于0到$3s$之间的数字最多可以用$\lceil \log_{10}(3s+1) \rceil = O(\log s)$位数字表示，程序中的每一行（形式为foo = NAND(bar,blah)）可以用$O(1) + O(\log s) = O(\log s)$个符号表示，每个符号又可以用7位表示。因此，一个$s$行程序可以表示为$O(s \log s)$位组成的字符串，由此得到以下定理：

```admonish quote title=""
{{thmc}}{thmc:t51}（将程序表示为字符串）

在一个常数$c$，使得对于$f \in SIZE(s)$，存在一个计算$f$的程序$P$，其字符串表示的长度最多为$c s \log s$。
```

```admonish pause title="暂停一下"
我们省略了{{tref:thmc:t51}}的正式证明，但请确保你理解为什么它可以从上述推理中得出。
```

## 5.2 程序数量统计与NAND-CIRC程序规模下界

将程序表示为字符串的必然结果是：特点长度的程序数量受限于可表示它们的字符串数量。这一结论对我们[4.6节]()定义的集合$SIZE_{n,m}(s)$具有重要意义。

```admonish quote title=""
{{thmc}}{thmc:t52}（程序计数定理）：

对于任意$s,n,m\in\N$，$SIZE_{n,m}(s)\le 2^{O(s\log s)}$。

这意味着最多存在$2^{O(s\log s)}$个函数可由不超过$s$行的NAND-CIRC程序计算。{{footnote: 其中$O(\cdot)$表示法中的隐常数小于10。也就是说，对于所有足够大的$s$，$|SIZ_{n,m}(s)<2^{10s\log s}|$，详见[备注5.2]()。如[1.7节](./chapter_1.md#17-本书所用到的符号及规范)所述，我们采用10这个界限值仅仅是因为它是个整数。}}
```

```admonish proof collapsible=true
对于任意$n,m\in\N$，我们将构造一个从$SIZE_{n,m}(s)$到长度为$cs\log s$的字符串集合的单射映射$E$（其中$c$为常数）。这将完成证明，因为该证明表明$|SIZE_{n,m}(s)|$小于长度至多为$\ell=cs\log s$的所有字符串集合的规模。根据等比数列求和公式，后一个集合的规模为$1+2+4+\cdots+2^\ell=2^{\ell+1}-1$。

映射$E$将简单地把函数$f$映射到计算$f$的最小程序表示。由于$f\in SIZE_{n,m}(s)$，根据{{tref:thmc:t51}}，存在一个最多$s$行的程序$P$，其字符串表示长度不超过$cs\log s$。此外，映射$f\mapsto E(f)$是单射，因为对于任意不同的函数$f,f':\{0,1\}^n\to\{0,1\}^m$，必然存在某个输入为$x\in\{0,1\}^n$使得$f(x)\ne f'(x)$。这意味着分别计算$f$和$f'$的程序不可能完全相同。
```

{{tref:thmc:t52}}有一个重要推论：可用小型电路/程序计算的函数数量远少于函数总数，因此必然存在需要非常大规模（实际上是指数级规模）电路才能计算的函数。理解这一点需要注意：映射$\{0,1\}^2$到$\{0,1\}$可由其在输入$00,01,10,11$上的四个值唯一确定;映射$\{0,1\}^3$到$\{0,1\}$的函数可尤其在输入$000,001,010,011,100,101,110,111$上的八个值唯一确定。更一般地，每个函数$F:\{0,1\}^n\to\{0,1\}$都可等同于其在$\{0,1\}^n$上$2^n$个取值组成的列表。因此，映射$\{0,1\}^n$到$\{0,1\}$的函数数量等于可能存在的$2^n$长度取值列表的数量，即$2^{2^n}$。注意这是关于$n$的双重指数函数，因此即使对于较小的$n$值（比如$n=10$），从$\{0,1\}^n$到$\{0,1\}$的函数数量也是真正的天文数字。{{footnote: “天文数字”在此是一种保守表述：可观测宇宙中的恒星数量甚至粒子数量都远少于$2^{2^{10} }$。}}如前所述，这引出了如下推论：

```admonish quote title=""
{{thmc}}{thmc:t53}（计数论证下界）

存在常数$\delta>0$，使得对于所有足够大的$n$，必然存在函数$f:\{0,1\}^n\to\{0,1\}$满足$f\notin SIZE_n\left(\tfrac{\delta 2^n}{n}\right)$。也就是说，计算$f$的最短NAND-CIRC程序需要超过$\delta\cdot 2^n/n$行。{{footnote: 常数$\delta$至少为0.1，实际上，可以通过[习题5.7]()将其进一步缩小为任意接近$1/2$的值。}}
```

```admonish proof collapsible=true
证明相当简单。令$c$为满足$|SIZ_n(s)|\le 2^{cs\log s}$的常数，且设$\delta=1/c$，则当$s=\delta 2^n/n$时，有：
$$
|SIZE_n(\tfrac{\delta 2^n}{n})| \leq 2^{c \tfrac{\delta 2^n}{n} \log s} < 2^{c \delta 2^n} = 2^{2^n}
$$
这里利用了$s<2^n$时$\log s<n$以及$\delta=1/c$的事实。由于$|SIZE_n(s)|$小于从$n$比特映射到1比特的函数总数，必然存在至少一个函数不属于$SIZE_n(s)$，这正是我们需要证明的结论。
```

我们此前已经知道：每个从$\{0,1\}^n$映射到$\{0,1\}$的函数都可由$O(2^n/n)$行程序计算。{{tref:thmc:t53}}表明了该界限是紧的，因为某些函数确实需要如此天文数字的行数才能计算。

```admonish check title="核心思想7"
某些函数$f:\{0,1\}^n\to\{0,1\}$无法通过门电路数量少于$n$的指数级的布尔电路来计算。
```

事实上，正如习题中所探讨的，**大多数**函数都属于这种情况。因此，能用少量代码行数计算的功能（如加法、乘法、图上的最短路径算法，甚至$EVAL$函数）只是例外而非普遍规律。

```admonish tip title="备注5.4（更高效的表示方法，高级可选内容）"
ASCII表示并非NAND-CIRC程序的最短表示形式。NAND-CIRC程序等价于带NAND门的电路，这意味着具有$s$行、$n$个输入和$m$个输出的NAND-CIRC程序可用包含$s+n$个顶点的标记有向图表示，其中$n$个顶点的入度为零，其余$s$个顶点的入度至多为二。使用此类图的邻接矩阵表示，我们可以将{{tref:thmc:t52}}中的隐常数降低到任意接近5的值，详见[习题5.6]()。
```

### 5.2.1 规模层次定理（可选）

## 5.3 元组的表示

### 5.3.1 从元组到字符串

## 5.4 使用NAND-CIRC实现的NAND-CIRC程序解释器

### 5.4.1 高效通用程序

### 5.4.2 “伪代码”形式的NAND-CIRC解释器

### 5.4.3 Python实现的NAND解释器

### 5.4.4 用NAND-CIRC构建NAND-CRIC解释器

## 5.5 用NAND-CIRC实现Python解释器（讨论）

## 5.6 物理扩展Church-Turing论题（讨论）

### 5.6.1 反驳PECTT的尝试

## 5.7 第一部分的回顾：有限计算

## 5.8 习题

## 5.9 参考书目
